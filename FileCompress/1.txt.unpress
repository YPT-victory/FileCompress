aaaaabbbbcccdde

功能验证测试：一般比较简单，在界面按照功能点击即可。
兼容性与用户测试：比如web浏览器的类型和版本号；公测就是让用户来进行测试。

客户端模拟测试：例如itest网站测试。
外部接口测试：例如平时的qq、微信授权登录等。
SDK接口测试：软件工程师特定的开发工具集合。

单元测试：代码测试代码，即开发人员的代码，我们测试人员自己写代码测试它们的代码的逻辑。
测试驱动开发：测试人员先编写测试用例，开发人员根据测试人员编写的测试用例再进行开发。

系统测试占用的时间是最长的。系统测试还包括回归测试、冒烟测试。
正确的操作顺序是：冒烟测试、系统测试、回归测试。

验收测试也叫交付测试。

α测试：在开发人员的公司环境进行测试，客户不参与。
β测试：在客户的公司环境进行测试，客户参与。

自动化测试都可以干什么？――冒烟测试和回归测试。

容错性测试：检查软件在异常条件下，自身是否具有防护性的措施或某种灾难性恢复的手段。
当系统出错时，能否在指定时间间隔内修正错误并重新启动系统。

#pragma once
#define _CRT_SECURE_NO_WARNINGS 1
#include"HuffmanTree.h"
#include<string>
#include<stdlib.h>

struct CharInFo
{
	unsigned char _ch;//字符这里用unsigned char，统计出现的字符
	long long _count;//字符出现的次数
	string _code;//Huffman编码

	bool operator < (const CharInFo& info)
	{
		return _count < info._count;
	}
	CharInFo operator + (const CharInFo& info)
	{
		CharInFo ret;
		ret._count = _count + info._count;
		return ret;
	}
	bool operator != (const CharInFo& info)
	{
		return _count != info._count;
	}
	CharInFo(long long count = 0)
		:_ch(0)
		,_count(count)
		,_code("")
	{}
};

class FileCompress
{
	typedef HuffmanTreeNode<CharInFo> Node;
public:
	struct ConfigInfo
	{
		unsigned char _ch;
		long long _count;
	};
	FileCompress()
	{
		//构造函数，初始化数组
		for(int i = 0; i<256; i++)
		{
			_infos[i]._ch = i;//初始化，0~255
			_infos[i]._count = 0;
		}
	}
	bool ComPress(const char* filename)
	{
		assert(filename);
		//1.统计字符出现的次数
		FILE* fout = fopen(filename, "rb");//打开文件以二进制方式读
		assert(fout);
		unsigned char ch = fgetc(fout);//读取文件字符
		long long charcount = 0;
		while(ch != EOF)
		{
			//feof是C语言的标准库函数，是检测流上的文件结束符
			//如果文件结束，则返回非0值，否则返回0
			if(feof(fout))
			{
				break;
			}
			_infos[ch]._count++;//此字符对应的次数
			ch = fgetc(fout);
			charcount++;
		}
		//2.构建Huffman树
		CharInFo invalid;
		invalid._count = 0;
		HuffmanTree<CharInFo> tree(_infos, 256, invalid);
		Node* root = tree.GetRoot();

		//3.生成Huffman编码
		string code;//huffman code
		GenerateHuffmanCode(root, code);
		//完成后charinfo中的_code中存的就是HuffmanCode

		//4.压缩
		string compressFile = filename;
		compressFile += ".huffman";//生成压缩文件
		FILE* fin = fopen(compressFile.c_str(), "wb");//打开压缩文件写
		assert(fin);
		fseek(fout, 0, SEEK_SET);//把文件指针指向源文件头
		//向压缩文件里写入Huffman编码
		unsigned char ch1 = fgetc(fout);//读源文件内容
		//这里用 unsigned 因为char是0~255，而中文是负数，就写不进去
		char value = 0;
		int pos = 0;
		while(ch1 != EOF)
		{
			if(feof(fout))
				break;
			string& code = _infos[ch1]._code;//每个字符的Huffman编码
			for(size_t i = 0; i < code.size(); i++)
			{
				value <<= 1;
				//先左移一位，如果code为1就进行下面的代码，把第一位变为1，为0就不处理
				//循环进行，就会把哪一位为1就把那一位置为1
				if(code[i] == '1')//得到二进制的1
				{
					value |= 1;
				}
				if(++pos == 8)//满8位写入文件
				{
					fputc(value, fin);//把value写进去，里面存的8个位就是HuffmanCode
					value = 0;//重置，循环写
					pos = 0;
				}
			}
			ch1 = fgetc(fout);
		}
		//到这里文件就读完了
		if(pos)//最后一个编码不足8个位
		{
			value = value << (8-pos);//作以，把那些没用的位去掉
			fputc(value, fin);
		}

		//5.写配置信息，字符和字符出现的次数都写进去
		string ConfigFilename = filename;
		ConfigFilename += ".config";
		FILE* fConfig = fopen(ConfigFilename.c_str(),"wb");
		assert(fConfig);
		char countStr[168];//字符出现的次数
		//先把所有字符出现的总次数写进配置文件，为防止超过int
		//范围，charcount使用的是 long long 所以要分两步写入，
		//所以为什么存了一个0，因为如果超过long long 的话转换高位可以
		//计算出正确的次数。
		//itoa(charcount >> 32, countStr, 10);
		//配置文件中的0
		//把字符转换成10进制数，因为文件中存的都是字符串，转换高位
		//fputs('\n',fConfig);
		//itoa(charcount & 0xffffffff, countStr, 10);//转换低位

		itoa(charcount, countStr, 10);
		fputs(countStr, fConfig);//把总次数写入
		fputc('\n', fConfig);//换行
		for(int i = 0; i < 256; i++)
		{
			string put;
			if(_infos[i] != invalid)
			{
				fputc(_infos[i]._ch, fConfig);
				//必须先把ch放进去，如果把ch作为string的字符最后转换为c的字符，会导致'\0'没有处理
				put.push_back(',');
				itoa(_infos[i]._count, countStr, 10);
				put += countStr;
				fputs(put.c_str(), fConfig);
				fputc('\n', fConfig);
			}
		}
		fclose(fin);
		fclose(fout);
		fclose(fConfig);
		return true;
	}
	bool UnCompress(const char* filename)
	{
		//1.读取配置文件   
		string ConfigFilename = filename;  
		int count = ConfigFilename.rfind('.');  
		ConfigFilename = ConfigFilename.substr(0, count);  
		string UnCompressname = ConfigFilename + ".unpress";   
		FILE* fUnCompress = fopen(UnCompressname.c_str(), "wb"); //创建解压缩文件  
		ConfigFilename += ".config";  
		FILE* fconfig = fopen(ConfigFilename.c_str(),"rb");
		assert(fconfig);
		assert(fUnCompress);
		FILE* fpress = fopen(filename,"rb");//打开压缩好的文件
		assert(fpress);

		long long charCount = 0;//找出字符出现的次数

		string line;
		_ReadLine(fconfig,line);
		charCount = atoi(line.c_str());
		line.clear();
		while(_ReadLine(fconfig,line))//文件结束会返回0
		{
			if(!line.empty())
			{
				unsigned char ch = line[0];//字符在前，读到
				string tmp = line.substr(2);//把前两个字符剪切掉
				//字符串的剪切，读出次数，在文件中都是以字符串的形式存在
				_infos[(unsigned char)ch]._count = atoi(tmp.c_str());  
				line.clear();
			}
			else//空行
			{
				line += '\n';
			}
		}
		//再次构建huffma树
		CharInFo invalid;
		invalid._count = 0;
		HuffmanTree<CharInFo> tree(_infos,256,invalid);
		Node* root = tree.GetRoot();
		Node* cur = root;
		char ch = fgetc(fpress);//读压缩文件
		int pos = 8;
		while(1)
		{
			--pos;
			if((ch>>pos)&1)//为1往右走
			{
				cur = cur->_right;
			}
			else//为0往左走
			{
				cur = cur->_left;
			}
			if(cur->_left==NULL&&cur->_right==NULL)//左右都为空，叶子，读出来
			{
				fputc(cur->_w._ch,fUnCompress);//读到解压缩的文件中
				cur = root;//再次从根节点遍历
				charCount--;//字符总数减减
			}
			if(pos == 0)//一个字节读完，重置，读下一个字节
			{
				ch = fgetc(fpress);
				pos = 8;//重置
			}
			if(charCount == 0)//当字符总数为0 则停止读
			{
				break;
			}
		}
		fclose(fconfig);
		fclose(fUnCompress);
		fclose(fpress);
		return true;
	}
protected:
	bool _ReadLine(FILE*filename,string&line)
	{
		assert(filename);
		if(feof(filename))
		{
			return false;
		}
		unsigned char ch = fgetc(filename);

		while(ch != '\n')
		{
			line += ch;
			ch = fgetc(filename);
			if(feof(filename))
			{
				return false;
			}
		}
		return true;
	}
	void GenerateHuffmanCode(Node* cur, string code)
	{
		if(cur == NULL)
			return;
		if(cur->_left == NULL && cur->_right == NULL)
		{
			_infos[(unsigned char)cur->_w._ch]._code = code;
			return;
		}
		GenerateHuffmanCode(cur->_left, code + '0');
		GenerateHuffmanCode(cur->_right, code + '1');
	}
protected:
	CharInFo _infos[256];
};

void TestCompress()
{
	FileCompress hft;
	int begin = GetTickCount();
	hft.ComPress("panpan.txt");
	int end = GetTickCount();
	cout<< end-begin << endl;
}
void TestUnCompress()  
{  
	FileCompress hf;  
	int begin = GetTickCount();  
	hf.UnCompress("panpan.txt.huffman");  
	int end = GetTickCount();  
	cout << end - begin << endl;  
}  



1.自我介绍
老师，您好！我是陕西科技大学文理学院数学与应用数学专业的一名学生，我叫杨盼婷，我今天面试的是测试开发工程师岗位，我熟悉C/C++的基本语法，掌握常用的数据结构与算法，熟悉在Windows和Linux环境下编程，熟悉Linux下的多线程和多进程，熟悉网络基础知识，了解TCP三次握手和四次挥手，熟悉socket编程，了解shell脚本，掌握mysql的简单使用，我相信我可以胜任这份工作。
2.你还有什么要问我的吗？
老师，我想问一下就是如果我通过面试进入了贵公司，有没有对新人的什么培训呢？
老师，我想请教一下您平时在工作中遇到问题是通过什么方式解决的呢？
3.怎样查看后台进程？

有两个命令可以用，jobs和ps,区别是jobs用于查看当前终端后台运行的任务，换了终端就看不到了。
而ps命令用于查看瞬间进程的动态，可以看到别的终端运行的后台进程。
4.什么是测试开发？
测试开发也算是一个职业，是指专门在为软件做测试的测试员。他们会有专门的测试工具，对开发的软件逐一调试，如果发现不符合软件开发目标（效果+功能），即视为出现debug，这就需要打回重新开发，即二次开发。
岗位的核心职能还是测试，是通过开发的手段提升测试的效率。
5.为什么要选择测试开发？
首先我咨询过老师，老师说女生心比较细比较适合测试方向，我自身心比较细腻 ，对事情追求完美，再加上我对研发有点兴趣，所以投了测试开发岗位。
6.你最敬佩的人？
在那位学长身上，我看到了他一往无前的拼劲，那种求知欲，通过自己的努力获得了想要的生活。

简单来说，这个聊天系统可以达到群聊的目的。
客户端向服务器发送消息，服务器对这条消息进行转发。
由于使用的是udp协议，所以服务器会维护一张用户列表，这个列表记录了所有向服务器发送过消息的客户地址。
当某个客户端退出的时候，会向服务器发送一条特殊的指令，然后服务器将该客户地址从用户列表中删除。

服务器模块：
1.接收客户端的消息，并且广播给所有的在线用户
能够存储在线好友列表（包含好友的昵称，ip地址）
能够感知到某个成员的上线和下线（使用hash表的形式来存储好友列表）
接受消息（生产者线程专门用于接受消息，把消息写入到一个队列中）
广播消息（消费者线程，从队列中读取消息，遍历好友列表，分别给每个好友发送消息）

客户端模块：
客户端需要能够：
1.显示在线好友列表
2.显示好友发送的消息
3.能够输入消息并发送
单独的创建一个线程用于处理对应的情况 

定制一个应用层协议：
json：是一种数据格式       json=>js         优点： 扩展性好，可读性好；缺点：空间占用比较大
Json优点和缺点：
优点：可读性好，方便解析
缺点：由于设计的比较美观，需要花销额外空间存储部分东西
1.服务器
从socket中读取数据，把数据转发给所有的在线成员，维护在线成员列表（unordered_map）
基于生产者消费者模型完成数据的转发
生产者线程负责从socket读取数据
消费者线程负责把数据转发给在线成员

2.客户端
能显示当前在线的成员
显示任意一个在线成员发送的消息
允许用户输入一条消息，并且将消息发送出去

交互接口（应用层协议）
成员昵称
成员的学校
发送的消息
控制命令
基于json进行序列化和反序列化

key用户身份的标识 ip + name（近似表示用户的身份）
0.UDP如何实现可靠传输？――回答：TCP为了达到可靠传输机制有哪些特性.
1.服务器启动时不能立刻获取到完整好友列表――扩展cmd指令来实现.
2.服务器保存的好友列表不能够持久化存储――文件json/数据.
3.如果客户端异常终止，服务器不能够正确的感知到好友列表的变化――模拟TCP中的保活机制，使用心跳包作为检测依据
4.假如好友列表存储在磁盘上，此时如果磁盘坏了，怎么办？
备份：
    a.把好友列表对应的文件备份到另外一台机器上，按照分钟级的维度进行拷贝到其他机器上.
    b.把这个数据写到数据库中，同时把这条数据写到两个数据库中.
    c.把这个数据写到数据库上，部署一个从数据库，配置主数据库和从数据库中的数据同步.
5.HTTP服务器 + 畅聊 => web版本的畅聊.
    客户端是浏览器打开的网页.
    服务器HTTP服务器 + 畅聊服务器的结合.
websocket、 ajax
6.移动端版本的畅聊（安卓/IOS）


内存泄漏memory leak :是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。
内存溢出 out of memory :指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM,即所谓的内存溢出。
二者的关系
	1. 
内存泄漏的堆积最终会导致内存溢出。
	2. 
内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误。
	3. 
内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。就相当于你租了个带钥匙的柜子，你存完东西之后把柜子锁上之后，把钥匙丢了或者没有将钥匙还回去，那么结果就是这个柜子将无法供给任何人使用，也无法被垃圾回收器回收，因为找不到他的任何信息。
	4. 
内存溢出：一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。这就是溢出。比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出。说白了就是我承受不了那么多，那我就报错。

#pragma once
#define _CRT_SECURE_NO_WARNINGS 1
#include"HuffmanTree.h"
#include<string>
#include<stdlib.h>

struct CharInFo
{
	unsigned char _ch;//字符这里用unsigned char，统计出现的字符
	long long _count;//字符出现的次数
	string _code;//Huffman编码

	bool operator < (const CharInFo& info)
	{
		return _count < info._count;
	}
	CharInFo operator + (const CharInFo& info)
	{
		CharInFo ret;
		ret._count = _count + info._count;
		return ret;
	}
	bool operator != (const CharInFo& info)
	{
		return _count != info._count;
	}
	CharInFo(long long count = 0)
		:_ch(0)
		,_count(count)
		,_code("")
	{}
};

class FileCompress
{
	typedef HuffmanTreeNode<CharInFo> Node;
public:
	struct ConfigInfo
	{
		unsigned char _ch;
		long long _count;
	};
	FileCompress()
	{
		//构造函数，初始化数组
		for(int i = 0; i<256; i++)
		{
			_infos[i]._ch = i;//初始化，0~255
			_infos[i]._count = 0;
		}
	}
	bool ComPress(const char* filename)
	{
		assert(filename);
		//1.统计字符出现的次数
		FILE* fout = fopen(filename, "rb");//打开文件以二进制方式读
		assert(fout);
		unsigned char ch = fgetc(fout);//读取文件字符
		long long charcount = 0;
		while(ch != EOF)
		{
			//feof是C语言的标准库函数，是检测流上的文件结束符
			//如果文件结束，则返回非0值，否则返回0
			if(feof(fout))
			{
				break;
			}
			_infos[ch]._count++;//此字符对应的次数
			ch = fgetc(fout);
			charcount++;
		}
		//2.构建Huffman树
		CharInFo invalid;
		invalid._count = 0;
		HuffmanTree<CharInFo> tree(_infos, 256, invalid);//构建Huffman树
		Node* root = tree.GetRoot();//Huffman树的根节点

		//3.生成Huffman编码
		string code;//huffman code
		GenerateHuffmanCode(root, code);
		//完成后charinfo中的_code中存的就是HuffmanCode


		//4.压缩
		string compressFile = filename;
		compressFile += ".huffman";//生成压缩文件
		FILE* fin = fopen(compressFile.c_str(), "wb");//以二进制写的形式打开压缩文件
		assert(fin);
		//int fseek ( FILE * stream, long int offset, int origin );
		fseek(fout, 0, SEEK_SET);//把文件指针指向源文件的起始位置
		//向压缩文件里写入Huffman编码
		unsigned char ch1 = fgetc(fout);//读源文件内容
		//这里用 unsigned  因为char是0~255，而中文是负数，就写不进去
		char value = 0;
		int pos = 0;
		while(ch1 != EOF)
		{
			if(feof(fout))
				break;

			string& code = _infos[ch1]._code;//每个字符的Huffman编码
			for(size_t i = 0; i < code.size(); i++)//一个一个比特位来进行放
			{
				value <<= 1;
				//先左移一位，如果code为1就进行下面的代码，把第一位变为1，为0就不处理
				//循环进行，就会把哪一位为1就把那一位置为1
				if(code[i] == '1')//得到二进制的1
				{
					value |= 1;//把原来为0的位置变为1，即就是写进1.
				}
				if(++pos == 8)//满8位写入文件
				{
					fputc(value, fin);//把value写进去，里面存的8个位就是HuffmanCode
					value = 0;//重置，循环写
					pos = 0;
				}
			}
			ch1 = fgetc(fout);
		}
		//到这里文件就读完了
		if(pos)//最后一个编码不足8个位
		{
			value = value << (8-pos);//不足一个字节，给后面补0再写进fin文件
			fputc(value, fin);
		}

		//5.写配置信息，字符和字符出现的次数都写进去
		string ConfigFilename = filename;
		ConfigFilename += ".config";
		FILE* fConfig = fopen(ConfigFilename.c_str(),"wb");
		assert(fConfig);
		char countStr[1024];//字符出现的次数
		//先把所有字符出现的总次数写进配置文件，为防止超过int范围，
		//charcount使用的是 long long 所以要分两步写入，所以为什么存了一个0，
		//因为如果超过long long 的话转换高位可以计算出正确的次数。
		//itoa(charcount >> 32, countStr, 10);
		//配置文件中的0
		//把字符转换成10进制数，因为文件中存的都是字符串，转换高位
		//fputs('\n',fConfig);
		//itoa(charcount & 0xffffffff, countStr, 10);//转换低位
		
		//char *  itoa ( int value, char * str, int base );
		itoa(charcount, countStr, 10);//把统计的次数转换成10进制
		fputs(countStr, fConfig);//把总次数写入
		fputc('\n', fConfig);//换行
		for(int i = 0; i < 256; i++)
		{
			string put;
			if(_infos[i] != invalid)
			{
				fputc(_infos[i]._ch, fConfig);
				//必须先把ch放进去，如果把ch作为string的字符最后转换为c的字符，会导致'\0'没有处理
				put.push_back(',');
				itoa(_infos[i]._count, countStr, 10);

				put += countStr;
				fputs(put.c_str(), fConfig);
				fputc('\n', fConfig);
			}
		}
		fclose(fin);
		fclose(fout);//关闭掉刚才打开的文件
		fclose(fConfig);
		return true;
	}
	bool UnCompress(const char* filename)
	{                                             
		//1.读取配置文件   
		string ConfigFilename = filename;  
		int count = ConfigFilename.rfind('.');  
		ConfigFilename = ConfigFilename.substr(0, count);  
		string UnCompressname = ConfigFilename + ".unpress";   
		FILE* fUnCompress = fopen(UnCompressname.c_str(), "wb"); //创建解压缩文件  
		ConfigFilename += ".config";  
		FILE* fconfig = fopen(ConfigFilename.c_str(),"rb");
		assert(fconfig);
		assert(fUnCompress);
		FILE* fpress = fopen(filename,"rb");//打开压缩好的文件
		assert(fpress);

		long long charCount = 0;//找出字符出现的次数

		string line;
		_ReadLine(fconfig,line);
		charCount = atoi(line.c_str());
		line.clear();
		while(_ReadLine(fconfig,line))//文件结束会返回0
		{
			if(!line.empty())
			{
				unsigned char ch = line[0];//字符在前，读到
				string tmp = line.substr(2);//把前两个字符剪切掉
				//字符串的剪切，读出次数，在文件中都是以字符串的形式存在
				_infos[(unsigned char)ch]._count = atoi(tmp.c_str());  
				line.clear();
			}
			else//空行
			{
				line += '\n';
			}
		}
		//再次构建huffma树
		CharInFo invalid;
		invalid._count = 0;
		HuffmanTree<CharInFo> tree(_infos,256,invalid);
		Node* root = tree.GetRoot();
		Node* cur = root;
		char ch = fgetc(fpress);//读压缩文件
		int pos = 8;
		while(1)
		{
			--pos;
			if((ch>>pos) & 1)//为1往右走
			{
				cur = cur->_right;
			}
			else//为0往左走
			{
				cur = cur->_left;
			}
			if(cur->_left==NULL && cur->_right==NULL)//左右都为空，叶子，读出来
			{
				fputc(cur->_w._ch,fUnCompress);//读到解压缩的文件中
				cur = root;//再次从根节点遍历
				charCount--;//字符总数减减
			}
			if(pos == 0)//一个字节读完，重置，读下一个字节
			{
				ch = fgetc(fpress);
				pos = 8;//重置
			}
			if(charCount == 0)//当字符总数为0,则停止读
			{
				break;
			}
		}
		fclose(fconfig);
		fclose(fUnCompress);
		fclose(fpress);
		return true;
	}
protected:
	bool _ReadLine(FILE*filename,string&line)
	{
		assert(filename);
		if(feof(filename))
		{
			return false;
		}
		unsigned char ch = fgetc(filename);

		while(ch != '\n')
		{
			line += ch;
			ch = fgetc(filename);
			if(feof(filename))
			{
				return false;
			}
		}
		return true;
	}
	void GenerateHuffmanCode(Node* cur, string code)//获取Huffman编码函数
	{
		if(cur == NULL)
			return; 
		if(cur->_left == NULL && cur->_right == NULL)
		{
			_infos[(unsigned char)cur->_w._ch]._code = code;
			return;
		}
		GenerateHuffmanCode(cur->_left, code + '0');//向左为0
		GenerateHuffmanCode(cur->_right, code + '1');//向右为1
	}
protected:
	CharInFo _infos[256];
};

void TestCompress()
{
	FileCompress hft;
	int begin = GetTickCount();
	hft.ComPress("panpan.txt");
	int end = GetTickCount();
	cout<< end-begin << endl;
}

void TestUnCompress()  
{  
	FileCompress hf;  
	int begin = GetTickCount();  
	hf.UnCompress("panpan.txt.huffman");  
	int end = GetTickCount();  
	cout << end - begin << endl;  
}  



